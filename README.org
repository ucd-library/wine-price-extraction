#+PROPERTY: header-args:sql :engine postgresql :cmdline "postgres://postgres@localhost:5433/postgres"

** Getting ARKs

The first order of business will be to get ARKs for each catalog.  Following the
guidelines we have laid out, we'll make these temporary, so we can remove them
if needed.  In addition, I am keeping this out of the Makefile so we don't
remake them too many times.

*** Collection ARK

The collection ARK, ark:/87287/d7wc7m, needs to be completed.

*** Item ARKS

First we need to login

#+BEGIN_SRC bash :results scalar
 http --session=qjhart -a ucd-qjhart:${PASSWORD} https://ezid.cdlib.org/login
#+END_SRC

Then we can use our catalog to run over each of these items;
#+BEGIN_SRC bash
alias mint='http --session=qjhart --print=b POST https://ezid.cdlib.org/shoulder/ark:/87287/d7 Content-Type:text/plain'
dc exec -u postgres -T postgres psql -A -F"|" -t --pset=footer \
-c "select catalog_id,mint(c) as ezid from catalogs c" |\
while IFS='|' read -r catalog_id ezid ; do \
  echo -e "$ezid" | mint | tee $catalog_id.ark ; echo '' | tee --append $catalog_id.ark;
done
#+END_SRC

Now, let's GET the records locally,  just so we have them;
\
#+BEGIN_SRC bash
mkdir -p ark:/87287
for i in ark/*.ark; do
 ark=$(cat $i | sed -e 's/success: //');
 http --session=qjhart --print=b GET https://ezid.cdlib.org/id/${ark} | \
 tee ${ark} ;
done
#+END_SRC

Then, let's get a csv file for input into our catalog table

#+BEGIN_SRC
for i in ark/*.ark; do
 n=$(basename $i .ark);
 ark=$(cat $i | sed -e 's/success: //');
 echo $n,$ark;
done > io/ark_xref.csv
#+END_SRC


#+BEGIN_SRC psql
create temp table xref (catalog_id uuid,ark text);
\COPY xref from /io/ark_xref.csv with csv
update catalogs as c set ark=x.ark from xref x where c.catalog_id=x.catalog_id;
#+END_SRC

** Create Catalog Record files

This time, I'm going to try and create the ttl files, using the javascript n3
data.

** copy the pages to their appropriate filename

This uses the postgres database, and a format statement to create a file copy to
the ARK filename.

#+BEGIN_SRC psql
select format('cp %s %s/media/images/%s-%3s.jpg',file,ark,regexp_replace(ark,'ark:.*/',''),LPAD(page::text,3,'0')) from jwalk;
#+END_SRC

We can also do the same thing with the DNGs. First, do the same ln -s trick,

#+BEGIN_SRC
ln -s /media/quinn/Seagate\ Expansion\ Drive/UCD_LEHMANN/UC_Sherry_Lehman/UCD_Lehman_Pics/UCD_Lehman dng
#+END_SRC

#+BEGIN_SRC
select format('cp dng/%s.dng %s/media/dngs/%s-%3s.dng',file,regexp_replace(ark,'ark:/','ark_'),
  regexp_replace(ark,'ark:.*/',''),LPAD(page::text,3,'0'))
from jwalk limit;
#+END_SRC

** Get the original OCR as a temporary fix.

api=https://wine-api.library.ucdavis.edu/
http '${api}/media?select=ocr&media_id=eq.${cat_$*}' > $@

#+BEGIN_SRC psql
format('curl ''https://wine-api.library.ucdavis.edu/media?select=ocr&media_id=eq.%s'' > %s/media/ocr.txt',catalog_id,ark,regexp_replace(ark,'ark:.*/','')) from jwalk where page=0;
#+END_SRC

** Get the current page images, so we can transfer the marks if possible.


#+BEGIN_SRC psql
select format('curl ''https://wine-api.library.ucdavis.edu/media?select=contents&media_id=eq.%s'' > %s/media/page_images/%s-%3s.png',page_id,regexp_replace(ark,'ark:/','ark_'),regexp_replace(ark,'ark:.*/',''),LPAD(page::text,3,'0')) from jwalk join pages using (catalog_id,page);
#+END_SRC


* Image Manipulation

Justin identified this potential helper documents on the Hough Filter,
https://www.imagemagick.org/discourse-server/viewtopic.php?t=25476

However, we really need to do a better job of getting the outline of the images.
My amerine menu script might be a good starting point. Searching for background
removal in imagemagick brings up some interesting stuff as well.

** Tesseract

I am running tesseract over all the current images as a first pass for ocr. I'm
hoping to be able to parse the html format and pull out all the rectangles that
I'll need.

for i in $(find .. -name \*.jpg ); do n=$(basename $i .jpg); echo $n; tesseract
$i $n -l eng --psm 1 --oem 1 txt hocr; done

It seem's that it will be easier to import JSON, rather than html.  I'll use pup
to convert to a simple json format.  This includes the filename, so I can import
easily with

#+BEGIN_SRC bash
for i in *.hocr ; do
 echo $i;
 pup 'div.ocr_page json{}' < $i | jq -c . | sed -e 's/\\/\\\\/g' >> hocr.json ;
done
#+END_SRC

Now that we have all the hocr in the database as JSON, we can start to look at
the words and lines that are in there.  Remember, we did NOT use any color
thresholding on these data yet.

#+BEGIN_SRC
create table hocr ( hocr jsonb);
\COPY hocr from ark_87287/tesseract/hocr.json
#+END_SRC


** Get the original marks.

*** Needed the original sizes of the images

Argh, I need the size of the images to do the maths.
#+BEGIN_SRC
for i in $(find ark_87287/* -name \*.jpg); do
 b=`basename $i .jpg'; s=$(jpeginfo --quiet $i | cut -d' ' -f 2,4 | tr ' ' ,);
 echo X,$b,$s;
done > size.csv

for i in $(find ark_87287/* -name \*.png); do
 b=`basename $i .png`;
 echo -n "L,$b"; pnginfo $i | grep 'Image Width' | sed -e 's/\s*Image [^0-9]*://g' | tr ' ' ,;
done >> size.csv

#+END_SRC

#+BEGIN_SRC sql
create table image_size (size char,page_ark text,x integer,y integer);
\COPY image_size from size.csv with csv;

create table image_extent as
select l.page_ark,
ARRAY[l.x,l.y]::integer[2] as pdf,
ARRAY[x.x,x.y]::integer[2] as image
from image_size l
join image_size x
on (l.size='L' and x.size='X' and l.page_ark=x.page_ark);
#+END_SRC

#+BEGIN_SRC
with a as (select page_id,count(*) from marks group by 1 order by 1) select
format('%s-%s',regexp_replace(ark,'ark:/','ark_'),lpad(page::text,3,'0')) as
page from a join pages using (page_id) join jwalk using (catalog_id,page) order
by page;
#+END_SRC

This is an example to start each in gimp
#+BEGIN_SRC
i=d78g6p-022; n=${i%-*}; gimp $n/media/images/$i.jpg $n/media/page_images/$i.png
#+END_SRC

#+header: :engine postgresql :cmdline "postgres://postgres@localhost:5433/postgres"
#+BEGIN_SRC sql
create table mark_xwalk (
page_ark text,
big_ll integer[2],
big_ur integer[2],
lit_ll integer[2],
lit_ur integer[2]
);
#+END_SRC


#+header: :engine postgresql :cmdline "postgres://postgres@localhost:5433/postgres"
#+BEGIN_SRC sql
copy mark_xwalk from stdin with csv header;
page_ark,big_ll,big_ur,little_ll,little_ur
d7001g-003,"{180,5433}","{3765,776}","{139,1357}","{1030,193}"
d70597-003,"{174,5421}","{3651,465}","{136,1365}","{1023,139}"
d70597-012,"{144,5478}","{3642,582}","{129,1371}","{1004,146}"
d70597-030,"{309,5508}","{3819,615}","{170,1339}","{1046,174}"
d7101s-025,"{171,5358}","{3669,627}","{132,1346}","{1008,156}"
d7101s-026,"{148,5372}","{3704,716}","{125,1343}","{1017,177}"
d71s3g-005,"{40,5371}","{3664,744}","{99,1342}","{1008,187}"
d72013-004,"{208,5480}","{3760,624}","{75,1482}","{1110,44}"
d72013-005,"{80,5480}","{3728,692}","{27,1480}","{1105,70}"
d72013-006,"{208,5544}","{3672,648}","{63,1495}","{1093,57}"
d72013-007,"{165,5472}","{3806,660}","{62,1483}","{1123,55}"
d72013-008,"{224,5552}","{3680,648}","{81,1492}","{1095,59}"
d72013-009,"{160,5464}","{3808,704}","{55,1483}","{1125,64}"
d72013-016,"{264,5520}","{3840,672}","{78,1486}","{1138,64}"
d72s3s-001,"{165,5265}","{3695,519}","{134,1362}","{1044,132}"
d72s3s-002,"{176,5328}","{3856,568}","{136,1329}","{1054,143}"
d7388t-003,"{796,3632}","{2840,184}","{194,1011}","{681,180}"
d7388t-004,"{772,3616}","{5128,196}","{183,1006}","{1233,181}"
d7388t-005,"{760,3624}","{5120,184}","{186,1011}","{1233,181}"
d7388t-006,"{768,3632}","{5104,184}","{187,1010}","{1230,181}"
d7388t-007,"{768,3624}","{5112,200}","{187,1010}","{1233,186}"
d73s33-006,"{272,5696}","{3976,672}","{162,1429}","{1087,168}"
d73w2r-001,"{144,5336}","{3648,624}","{129,1333}","{999,153}"
d73w2r-002,"{112,5208}","{3688,592}","{115,1303}","{1015,145}"
d73w2r-003,"{256,5344}","{3640,624}","{156,1344}","{1005,155}"
d73w2r-004,"{104,5216}","{3690,572}","{117,1299}","{1012,147}"
d73w2r-005,"{144,5320}","{3641,611}","{132,1332}","{1005,151}"
d73w2r-006,"{104,5208}","{3688,576}","{118,1303}","{1011,142}"
d73w2r-007,"{152,5328}","{3648,616}","{130,1330}","{1006,153}"
d73w2r-008,"{96,5216}","{3688,592}","{120,1303}","{1012,144}"
d73w2r-013,"{152,5336}","{3592,600}","{129,1335}","{988,151}"
d74s3d-003,"{248,5584}","{3952,552}","{154,1396}","{1077,138}"
d75k5d-006,"{120,5144}","{3824,584}","{123,1287}","{1048,147}"
d75p42-001,"{272,5256}","{3848,576}","{160,1311}","{1053,147}"
d75p42-003,"{272,5248}","{3848,592}","{163,1311}","{1054,142}"
d76k5q-008,"{208,5368}","{3720,616}","{145,1344}","{1024,157}"
d76p4c-017,"{208,5528}","{3792,768}","{145,1383}","{1039,193}"
d76p4c-019,"{208,5528}","{3792,776}","{141,1381}","{1041,192}"
d77p4p-013,"{440,3894}","{5335,187}","{102,1080}","{1286,184}"
d78g6p-022,"{360,4920}","{3824,248}","{184,1255}","{1045,60}"
d7988p-009,"{224,5448}","{3848,776}","{150,1368}","{1056,190}"
d79w2m-004,"{168,5432}","{3928,672}","{59,1474}","{1155,64}"
d79w2m-008,"{232,5456}","{3912,656}","{73,1476}","{1161,60}"
d79w2m-009,"{184,5390}","{3921,638}","{67,1470}","{1162,51}"
d79w2m-013,"{136,5432}","{3834,648}","{43,1471}","{1140,49}"
d79w2m-014,"{40,5368}","{3800,687}","{13,1456}","{1128,67}"
d79w2m-023,"{192,5432}","{3848,624}","{58,1471}","{1150,54}"
d79w2m-025,"{80,5360}","{3864,624}","{42,1473}","{1140,54}"
d79w2m-026,"{120,5384}","{3880,672}","{58,1475}","{1150,64}"
d79w2m-029,"{120,5400}","{3824,608}","{38,1461}","{1129,43}"
d79w2m-030,"{216,5392}","{3936,616}","{69,1459}","{1164,51}"
d79w2m-034,"{160,5384}","{3904,656}","{54,1456}","{1152,51}"
d79w2m-037,"{112,5400}","{3856,608}","{37,1461}","{1140,43}"
d79w2m-038,"{72,5352}","{3784,576}","{28,1446}","{1126,36}"
d7b01k-001,"{616,3768}","{5184,200}","{1,1171}","{1402,61}"
d7b880-008,"{96,5872}","{3808,336}","{117,1467}","{1044,85}"
d7bc7n-029,"{0,5696}","{3776,672}","{94,1426}","{1033,163}"
d7c889-012,"{216,5488}","{3824,496}","{145,1371}","{1048,123}"
d7d59z-007,"{0,5808}","{3992,248}","{93,1456}","{1084,60}"
d7ds3w-012,"{272,5160}","{3832,576}","{159,1288}","{1050,145}"
d7f598-021,"{288,5440}","{3872,744}","{165,1359}","{1057,183}"
d7g01t-007,"{160,5448}","{3760,736}","{127,1360}","{1038,177}"
d7g01t-025,"{168,5448}","{3760,712}","{133,1363}","{1033,180}"
d7g59k-003,"{184,4912}","{3840,728}","{136,1228}","{1050,181}"
d7g59k-004,"{264,5160}","{3872,920}","{156,1297}","{1063,229}"
d7h014-001,"{536,3896}","{5544,104}","{129,1074}","{1332,163}"
d7h014-013,"{644,3852}","{5504,112}","{151,1063}","{1324,163}"
d7h014-014,"{648,3856}","{5472,96}","{157,1065}","{1321,166}"
d7h59w-003,"{176,5472}","{3704,744}","{135,1365}","{1024,198}"
d7h59w-017,"{168,5472}","{3696,712}","{135,1369}","{1018,183}"
d7j01f-007,"{168,5784}","{3800,80}","{130,1446}","{1036,21}"
d7j01f-021,"{192,5760}","{3856,80}","{139,1441}","{1054,16}"
d7js34-025,"{200,5440}","{3712,744}","{144,1362}","{1017,184}"
d7js34-026,"{368,5264}","{3848,560}","{187,1315}","{1060,141}"
d7k01r-001,"{104,5344}","{3664,664}","{117,1333}","{1000,165}"
d7kw23-008,"{256,5336}","{3723,808}","{151,1335}","{1018,201}"
d7kw23-009,"{312,5360}","{3704,784}","{181,1344}","{1018,192}"
d7kw23-010,"{224,5344}","{3712,808}","{142,1336}","{1026,199}"
d7ms3r-029,"{304,5336}","{3728,632}","{165,1333}","{1030,159}"
d7ms3r-030,"{152,5280}","{3696,648}","{132,1326}","{1014,166}"
d7mw2d-002,"{384,3960}","{5512,112}","{90,1092}","{1327,163}"
d7mw2d-003,"{376,3944}","{5528,120}","{87,1087}","{1329,166}"
d7nk5r-002,"{272,5576}","{3768,608}","{160,1398}","{1039,156}"
d7pk52-003,"{232,5392}","{3704,400}","{156,1356}","{1015,100}"
d7pp4q-011,"{176,5288}","{3696,512}","{136,1326}","{1017,132}"
d7pp4q-023,"{184,5296}","{3760,520}","{133,1329}","{1027,129}"
d7ps3c-002,"{224,5768}","{3704,568}","{147,1447}","{1054,171}"
d7ps3c-006,"{152,5720}","{3680,592}","{126,1431}","{1020,150}"
d7qp41-006,"{184,5264}","{3656,744}","{136,1317}","{1006,190}"
d7qp41-014,"{368,5360}","{3800,840}","{184,1344}","{1044,205}"
d7qs3p-005,"{128,5392}","{3832,728}","{120,1347}","{1047,177}"
d7s881-005,"{72,5520}","{3688,784}","{115,1383}","{1032,208}"
d7sg6b-004,"{104,5248}","{3736,576}","{117,1311}","{1026,147}"
d7sg6b-014,"{128,5232}","{3736,584}","{126,1314}","{1023,151}"
d7tg6n-004,"{128,5272}","{3806,599}","{121,1320}","{1047,150}"
d7v88n-004,"{176,5488}","{3936,688}","{55,1492}","{1167,67}"
d7vc79-003,"{392,5280}","{3864,760}","{187,1323}","{1053,190}"
d7vc79-007,"{392,5280}","{3840,768}","{187,1327}","{1051,192}"
d7vc79-026,"{304,5192}","{3616,632}","{165,1305}","{993,156}"
d7vc79-028,"{304,5200}","{3560,648}","{165,1306}","{985,160}"
d7w88z-016,"{248,5312}","{3856,648}","{154,1327}","{1056,162}"
d7ws37-000,"{416,5968}","{3648,224}","{193,1495}","{1009,55}"
d7ws37-004,"{384,5992}","{3600,272}","{184,1492}","{990,69}"
d7x30h-016,"{272,5248}","{3848,592}","{160,1309}","{1050,150}"
d7z30t-008,"{96,5424}","{3760,592}","{30,1465}","{1116,39}"
#+END_SRC

#+RESULTS:
| COPY 105 |
|----------|

#+header: :engine postgresql :cmdline "postgres://postgres@localhost:5433/postgres"
#+BEGIN_SRC sql
create table crowd_source_marks as
with
p as (
select
page_id,file,
format('%s-%s',regexp_replace(ark,'ark:/','ark_'),lpad(page::text,3,'0')) as page_ark
from pages join jwalk using (catalog_id,page)
)
select
file,page_ark,
xy as pdf_xy,
type,wine_type,color,county as country,name,section,vintage,bottle_type,perprice,caseprice,
ARRAY[(((big_ur[1]-big_ll[1])::float/(lit_ur[1]-lit_ll[1]))*(xy[1]-lit_ll[1]) + big_ll[1])::integer,
 (((big_ur[2]-big_ll[2])::float/(lit_ur[2]-lit_ll[2]))*(xy[2]-(e.pdf[2]-lit_ll[2])) + (e.image[2] - big_ll[2]))::integer
]::integer[2] as xy
from marks left join
p using (page_id) left join
mark_xwalk using (page_ark)
left join image_extent e using (page_ark)
order by file,xy[2];

alter table crowd_source add column mark_id serial primary key;
alter table crowd_source add column pt geometry(POINT,3310);
update crowd_source set pt=st_setsrid(st_makepoint(xy[1],xy[2]),3310);

#+END_SRC

#+RESULTS:
| CREATE VIEW |
|-------------|

#+BEGIN_SRC
 \COPY (select file,page_ark,type,wine_type,color,country,name,section,vintage,bottle_type,perprice,caseprice,st_x(pt),-st_y(pt) from crowd_source order by file,(st_x(pt)/200)::integer,st_y(pt) desc) to crowd_source with csv header;

#+END_SRC


* Price Finding Functions

This query finds potential prices

#+BEGIN_SRC sql
drop view if exists prices cascade;
create view prices as
with a as (
 select *,
 st_makepoint(st_xmax(bbox),0) as rhs_0
 from words where text~'^\d\d*\.\d\d$'
)
select * from a;
#+END_SRC

#+RESULTS:
| DROP VIEW   |
|-------------|
| CREATE VIEW |

#+BEGIN_SRC sql
select ark,line_id,count(*)
from a
group by 1,2
order by 3 desc;
#+END_SRC

This query trys to find non-price numbers that aren't vintages.  The idea here
is that these have identifiers in them.

#+header: :engine postgresql :cmdline "postgres://postgres@localhost:5433/postgres"
#+BEGIN_SRC sql
drop view if exists identifiers cascade;
create view identifiers as
with a as (
 select ark, word_id,text,bbox,
 st_makepoint(st_xmin(bbox),0) as lhs_0
 from words
 where text~'^\d\d\d+$' and not text ~ '^19..')
select * from a;
#+END_SRC

#+RESULTS:
| DROP VIEW   |
|-------------|
| CREATE VIEW |


#+BEGIN_SRC sql
  create or replace view price_cols as
  with a as (
    select ark,text,st_ymin(bbox) as y,st_x(rhs_0) as x,
    ST_ClusterDBSCAN(rhs_0, eps := 50, minpoints:=6)
    over (partition by ark) as col
    from prices
  )
  select ark,col,
  array_agg(text order by y) as text,
  array_agg(x order by y) as x    ,
  array_agg(y order by y) as y
  from a group by ark,col
#+END_SRC

#+RESULTS:
| CREATE VIEW |
|-------------|

#+BEGIN_SRC sql
  create or replace view rotate as
  with a as (
    select ark,'id'::text as type,bbox,
    ST_ClusterDBSCAN(lhs_0, eps := 50, minpoints:=6)
    over (partition by ark) as col
    from identifiers
   union
   select ark,'price'::text as type,bbox,
   ST_ClusterDBSCAN(rhs_0, eps := 50, minpoints:=6)
   over (partition by ark) as col
   from prices
  ),
  b as (
  select ark,type,col,
  case when (type='id')
   then regr_slope(st_xmin(bbox),-st_ymin(bbox))
   else regr_slope(st_xmax(bbox),-st_ymin(bbox))
  end as slope
  from a where col is not null group by ark,type,col
  ),
  c as (
  select ark,type,col,slope*180/3.14159 as rotation
  from b
  )
  select * from c;


#+END_SRC

#+RESULTS:
| CREATE VIEW |
|-------------|

Creating our rotated datasets.

#+BEGIN_SRC bash
for i in $(psql -At postgres://postgres@localhost:5433/postgres \
-c "with a as (select ark,type,avg(rotation)::decimal(6,2) as r,max(rotation)-min(rotation) as delta,array_agg(rotation order by rotation) as rs from rotate group by ark,type) select ark,r from a where type='price' order by delta desc"); do
 echo $i; \
done | wc -l
#+END_SRC

#+RESULTS:
: 1656


#+BEGIN_SRC bash
PG="psql -At postgres://postgres@localhost:5433/postgres"
read -r -d '' sql <<SQL;
with a as (
 select ark,type,avg(rotation)::decimal(6,2) as r
 from rotate group by ark,type
)
select ark,
case when(r<0) THEN 360+r ELSE r END as r
from a where type='price' order by a.r asc
SQL

for i in $(psql $PG -c "$sql" | head -2); do
  IFS='|' read ark r <<<"$i";
  d=${ark%-*};
  o=ark_87287/tesseract/rotate/$ark;
  url="https://sandbox.dams.library.ucdavis.edu/fcrepo/rest/collection/sherry-lehmann/catalogs/$d/media/images/$ark/svc:tesseract/full/full/$r/default.jpg Accept:application/hocr+xml";
  echo $ark $r;
  echo "r=$r" > $o.r;
  echo $url >>$o.r;
  http --output=$o.hocr $url;
done
#+END_SRC

#+RESULTS:

* Extracting title,date from metadata.ttl

Eric needed a spreadsheet of the catalog data.  This is how I got that to him.
This uses the apache JENA command line.

#+BEGIN_SRC bash
for i in ark_87287/*; do
  n=$(echo $i | tr '_' ':');
  echo -n "$n,";
  sparql --data=$i/metadata.ttl --results=CSV --query=- <<<"prefix : <http://schema.org/>  select ?n ?d WHERE { ?s :name ?n . ?s :datePublished ?d . }" 2>/dev/null | tail -1;
done | tee catalog_list.csv

#+END_SRC
